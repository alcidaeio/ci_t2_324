"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chokidar_1 = __importDefault(require("chokidar"));
const path_1 = require("path");
const reporter_1 = require("../reporter");
const minimatch_1 = __importDefault(require("minimatch"));
const BUILTIN_IGNORED_DIRS = ['node_modules', '.git', '.yarn', '.pnp'];
function createIsIgnored(ignored, excluded) {
    const ignoredPatterns = ignored ? (Array.isArray(ignored) ? ignored : [ignored]) : [];
    const ignoredFunctions = ignoredPatterns.map((pattern) => {
        // ensure patterns are valid - see https://github.com/TypeStrong/fork-ts-checker-webpack-plugin/issues/594
        if (typeof pattern === 'string') {
            return (path) => minimatch_1.default(path, pattern);
        }
        else if (typeof pattern === 'function') {
            return pattern;
        }
        else if (pattern instanceof RegExp) {
            return (path) => pattern.test(path);
        }
        else {
            // fallback to no-ignore function
            return () => false;
        }
    });
    ignoredFunctions.push((path) => excluded.some((excludedPath) => path.startsWith(excludedPath)));
    ignoredFunctions.push((path) => BUILTIN_IGNORED_DIRS.some((ignoredDir) => path.includes(`/${ignoredDir}/`) || path.includes(`\\${ignoredDir}\\`)));
    return function isIgnored(path) {
        return ignoredFunctions.some((ignoredFunction) => ignoredFunction(path));
    };
}
class InclusiveNodeWatchFileSystem {
    constructor(watchFileSystem, compiler, pluginState) {
        this.watchFileSystem = watchFileSystem;
        this.compiler = compiler;
        this.pluginState = pluginState;
        this.paused = true;
        this.dirsWatchers = new Map();
    }
    get watcher() {
        var _a;
        return this.watchFileSystem.watcher || ((_a = this.watchFileSystem.wfs) === null || _a === void 0 ? void 0 : _a.watcher);
    }
    watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
        var _a, _b, _c, _d;
        reporter_1.clearFilesChange(this.compiler);
        const isIgnored = createIsIgnored(options === null || options === void 0 ? void 0 : options.ignored, ((_a = this.pluginState.lastDependencies) === null || _a === void 0 ? void 0 : _a.excluded) || []);
        // use standard watch file system for files and missing
        const standardWatcher = this.watchFileSystem.watch(files, dirs, missing, startTime, options, callback, callbackUndelayed);
        (_b = this.watcher) === null || _b === void 0 ? void 0 : _b.on('change', (file) => {
            if (typeof file === 'string' && !isIgnored(file)) {
                reporter_1.updateFilesChange(this.compiler, { changedFiles: [file] });
            }
        });
        (_c = this.watcher) === null || _c === void 0 ? void 0 : _c.on('remove', (file) => {
            if (typeof file === 'string' && !isIgnored(file)) {
                reporter_1.updateFilesChange(this.compiler, { deletedFiles: [file] });
            }