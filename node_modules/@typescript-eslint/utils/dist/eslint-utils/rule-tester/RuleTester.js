"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _RuleTester_baseOptions, _RuleTester_afterAll;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleTester = exports.noFormat = void 0;
const assert_1 = __importDefault(require("assert"));
const package_json_1 = require("eslint/package.json");
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const BaseRuleTester = __importStar(require("../../ts-eslint/RuleTester"));
const deepMerge_1 = require("../deepMerge");
const dependencyConstraints_1 = require("./dependencyConstraints");
const TS_ESLINT_PARSER = '@typescript-eslint/parser';
const ERROR_MESSAGE = `Do not set the parser at the test level unless you want to use a parser other than ${TS_ESLINT_PARSER}`;
function isDescribeWithSkip(value) {
    return (typeof value === 'object' &&
        value != null &&
        'skip' in value &&
        typeof value.skip === 'function');
}
class RuleTester extends BaseRuleTester.RuleTester {
    /**
     * If you supply a value to this property, the rule tester will call this instead of using the version defined on
     * the global namespace.
     */
    static get afterAll() {
        var _b;
        return ((_b = __classPrivateFieldGet(this, _a, "f", _RuleTester_afterAll)) !== null && _b !== void 0 ? _b : (typeof afterAll === 'function' ? afterAll : () => { }));
    }
    static set afterAll(value) {
        __classPrivateFieldSet(this, _a, value, "f", _RuleTester_afterAll);
    }
    get staticThis() {
        // the cast here is due to https://github.com/microsoft/TypeScript/issues/3841
        return this.constructor;
    }
    constructor(baseOptions) {
        var _b, _c;
        // eslint will hard-error if you include non-standard top-level properties
        const { dependencyConstraints: _ } = baseOptions, baseOptionsSafeForESLint = __rest(baseOptions, ["dependencyConstraints"]);
        super(Object.assign(Object.assign({}, baseOptionsSafeForESLint), { parserOptions: Object.assign(Object.assign({}, baseOptions.parserOptions), { warnOnUnsupportedTypeScriptVersion: (_c = (_b = baseOptions.parserOptions) === null || _b === void 0 ? void 0 : _b.warnOnUnsupportedTypeScriptVersion) !== null && _c !== void 0 ? _c : false }), 
            // as of eslint 6 you have to provide an absolute path to the parser
            // but that's not as clean to type, this saves us trying to manually enforce
            // that contributors require.resolve everything
            parser: require.resolve(baseOptions.parser) }));
        _RuleTester_baseOptions.set(this, void 0);
        __classPrivateFieldSet(this, _RuleTester_baseOptions, baseOptions, "f");
        // make sure that the parser doesn't hold onto file handles between tests
        // on linux (i.e. our CI env), there can be very a limited number of watch handles available
        this.staticThis.afterAll(() => {
            try {
                // instead of creating a hard dependency, just use a soft require
                // a bit weird, but if they're using this tooling, it'll be installed
                const parser = require(TS_ESLINT_PARSER);
                parser.clearCaches();
            }
            catch (_b) {
                // ignored on purpose
            }
        });
    }
    getFilename(testOptions) {
        var _b;
        const resolvedOptions = (0, deepMerge_1.deepMerge)(__classPrivateFieldGet(this, _RuleTester_baseOptions, "f").parserOptions, testOptions);
        const filename = `file.ts${((_b = resolvedOptions.ecmaFeatures) === null || _b === void 0 ? void 0 : _b.jsx) ? 'x' : ''}`;
        if (resolvedOptions.project) {
            return path.join(resolvedOptions.tsconfigRootDir != null
                ? resolvedOptions.tsconfigRootDir
                : process.cwd(), filename);
        }
        return filename;
    }
    // as of eslint 6 you have to provide an absolute path to the parser
    // If you don't do that at the test level, the test will fail somewhat cryptically...
    // This is a lot more explicit
    run(name, rule, testsReadonly) {
        if (__classPrivateFieldGet(this, _RuleTester_baseOptions, "f").dependencyConstraints &&
            !(0, dependencyConstraints_1.satisfiesAllDependencyConstraints)(__classPrivateFieldGet(this, _RuleTester_baseOptions, "f").dependencyConstraints)) {
            if (isDescribeWithSkip(this.staticThis.describe)) {
                // for fra